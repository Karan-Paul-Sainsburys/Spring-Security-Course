package com.karanpaul.springsecurity.config;

import com.karanpaul.springsecurity.exceptionHandling.CustomAccessDeniedHandler;
import com.karanpaul.springsecurity.exceptionHandling.CustomAuthenticationEntryPoint;
import com.karanpaul.springsecurity.filter.CsrfCookieFilter;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.security.authentication.password.CompromisedPasswordChecker;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.password.HaveIBeenPwnedRestApiPasswordChecker;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;
import org.springframework.security.web.csrf.CsrfTokenRepository;
import org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler;
import org.springframework.security.web.csrf.CsrfTokenRequestHandler;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;

import java.util.Collections;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@Profile("!prod") // other than prod for all profile this will be used
public class SecurityConfig {
//    @Bean
//    SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
//        CsrfTokenRequestAttributeHandler csrfTokenRequestAttributeHandler = new CsrfTokenRequestAttributeHandler();
////        http.requiresChannel(rcf->rcf.anyRequest().requiresSecure()) //will allow only https hit
//        //this allowes the session management to restrict to 2 sessions and maxSessions.. disables
//        //further login if the max is reached and expiredURL redirects to a different custom page for it
////        http.sessionManagement(smc->smc.sessionFixation(sfc->sfc.migrateSession())); //setting the session to migrateSession strategy
////        http.sessionManagement(smc->smc.maximumSessions(2).maxSessionsPreventsLogin(true).expiredUrl("/current-sessions"));  giving maximum session and redirecting to a URL
//        //http.sessionManagement(smc -> smc.invalidSessionUrl("/invalidSession")) //for redirecting to different url for session login when expired
//        http.sessionManagement(smc->smc.sessionCreationPolicy(SessionCreationPolicy.ALWAYS)); // for always creating a Jsession Id (because if CSRF token is generated by default the Jsession id will not be generated)
//        http.cors(httpSecurityCorsConfigurer -> httpSecurityCorsConfigurer.configurationSource(new WebCORSConfigurations()));
//                http.csrf(csrfconfig -> csrfconfig
////                                .csrfTokenRequestHandler(csrfTokenRequestAttributeHandler)
//                                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()))
//                        .addFilterAfter(new CsrfCookieFilter(), BasicAuthenticationFilter.class)
//                        .authorizeHttpRequests((requests) -> requests
//                                .requestMatchers("/myAccount","/myCard","/myBalance","/myLoans","/user").authenticated()
//                                .requestMatchers("/notices","/contacts","/welcome","/current-sessions","/register").permitAll());
//        http.formLogin(withDefaults());
//        http.httpBasic(hfc -> hfc.authenticationEntryPoint(new CustomAuthenticationEntryPoint())); //for
//        // invoking the custom authentication entry point for basic auth.
//
//        //for global exception handling, we can use this as well and this will handle all global exception which we write within the class.
//        //http.exceptionHandling(ehc->ehc.authenticationEntryPoint(new CustomAuthenticationEntryPoint()));
//        http.exceptionHandling(ehc->ehc.accessDeniedHandler(new CustomAccessDeniedHandler()));
//        return http.build();
//    }
    @Bean
    SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        CsrfTokenRequestAttributeHandler csrfTokenRequestAttributeHandler = new CsrfTokenRequestAttributeHandler();
        http.securityContext(contextConfig -> contextConfig.requireExplicitSave(false))
            .sessionManagement(sessionConfig -> sessionConfig.sessionCreationPolicy(SessionCreationPolicy.ALWAYS))
            .cors(corsConfig -> corsConfig.configurationSource(new WebCORSConfigurations()))
            .csrf(csrfConfig -> csrfConfig.csrfTokenRequestHandler(csrfTokenRequestAttributeHandler)
                    .ignoringRequestMatchers( "/contact","/register")
                    .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()))
            .addFilterAfter(new CsrfCookieFilter(), BasicAuthenticationFilter.class)
            .requiresChannel(rcc -> rcc.anyRequest().requiresInsecure()) // Only HTTP
            .authorizeHttpRequests((requests) -> requests
                    .requestMatchers("/myAccount", "/myBalance", "/myLoans", "/myCards", "/user").authenticated()
                    .requestMatchers("/notices", "/contact", "/error", "/register", "/invalidSession").permitAll());
        http.formLogin(withDefaults());
        http.httpBasic(hbc -> hbc.authenticationEntryPoint(new CustomAuthenticationEntryPoint()));
        http.exceptionHandling(ehc -> ehc.accessDeniedHandler(new CustomAccessDeniedHandler()));
        return http.build();
    }

//    //using the JDBCUserDetailsManager to authenticate the users from DB
//    @Bean
//    public UserDetailsService userDetailsService(DataSource dataSource){
//        return new JdbcUserDetailsManager(dataSource);
//    }

    @Bean
    PasswordEncoder passwordEncoder(){
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }

    @Bean
    CompromisedPasswordChecker compromisedPasswordChecker(){
        return new HaveIBeenPwnedRestApiPasswordChecker();
    }
}
